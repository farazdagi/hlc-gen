#![doc = include_str!("../README.md")]

pub mod error;

use {
    crate::error::{HlcError, HlcResult},
    chrono::Utc,
    parking_lot::RwLock,
    std::sync::Arc,
};

/// State of hybrid logical clock (HLC).
#[derive(Hash, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]
pub struct HlcTimestamp {
    /// Wall-clock time in nanoseconds since the Unix epoch.
    timestamp: i64,

    /// The logical clock value, captures causality for events that occur at the
    /// same wall-clock time.
    count: u64,
}

impl HlcTimestamp {
    /// Creates a new HLC timestamp.
    pub fn new(timestamp: i64, count: u64) -> Self {
        Self { timestamp, count }
    }
    
    /// Returns the wall-clock time in nanoseconds since the Unix epoch.
    pub fn timestamp(&self) -> i64 {
        self.timestamp
    }
    
    /// Returns the logical clock value.
    pub fn count(&self) -> u64 {
        self.count
    }
}

/// Hybrid Logical Clock (HLC) generator.
pub struct HlcGenerator {
    inner: Arc<RwLock<InnerHlcClock>>,
}

struct InnerHlcClock {
    /// The maximum drift (in nanoseconds) allowed between the physical clock
    /// and the wall-clock time.
    max_drift: usize,

    /// The last timestamp generated by the clock.
    state: HlcTimestamp,
}

impl Default for HlcGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl HlcGenerator {
    /// Creates a new HLC clock without any drift.
    ///
    /// Whenever the clock running on a single node is required, there is no
    /// need to worry about drift, as no adjustments are made to the clock,
    /// i.e. [`update()`](HlcClock::update) is never called.
    pub fn new() -> Self {
        Self::with_max_drift(0)
    }

    /// Creates a new HLC clock with the specified maximum drift.
    pub fn with_max_drift(max_drift: usize) -> Self {
        Self {
            inner: Arc::new(RwLock::new(InnerHlcClock {
                max_drift,
                state: HlcTimestamp {
                    timestamp: current_timestamp().unwrap_or(0),
                    count: 0,
                },
            })),
        }
    }

    /// Gets the current timestamp from the HLC clock.
    pub fn timestamp(&self) -> HlcTimestamp {
        let inner = self.inner.read();
        inner.state.clone()
    }

    /// Get next timestamp from the HLC clock.
    pub fn next_timestamp(&self) -> Option<HlcTimestamp> {
        let mut inner = self.inner.write();

        let timestamp = current_timestamp()?;
        if inner.state.timestamp >= timestamp {
            // Known timestamp is not outdated, increment the logical count.
            inner.state.count += 1;
        } else {
            // Known timestamp is outdated, update timestamp and reset the logical count.
            inner.state.count = 0;
        }
        Some(inner.state.clone())
    }

    /// Adjust the clock based on incoming timestamp.
    ///
    /// Usually this happens when a timestamp is received from another node.
    /// An error may occur if drift is exceeded (if `max_drift` is set to 0,
    /// then such a check is ignored).
    ///
    /// Updated timestamp is returned.
    pub fn update(&self, incoming_state: HlcTimestamp) -> HlcResult<HlcTimestamp> {
        let mut inner = self.inner.write();

        let timestamp = current_timestamp().ok_or(HlcError::OutOfRangeTimestamp)?;

        // Physical clock is ahead of both the incoming timestamp and the current state.
        if timestamp > incoming_state.timestamp && timestamp > inner.state.timestamp {
            // Update the clock state.
            inner.state = HlcTimestamp {
                timestamp,
                count: 0,
            };
            return Ok(inner.state.clone());
        }

        if incoming_state.timestamp > inner.state.timestamp {
            // Check for drift.
            let drift = (incoming_state.timestamp - timestamp) as usize;
            if inner.max_drift > 0 && drift > inner.max_drift {
                return Err(HlcError::DriftTooLarge(drift, inner.max_drift));
            } else {
                // Remote timestamp is ahead of the current state. Update local state.
                inner.state.timestamp = incoming_state.timestamp;
                inner.state.count = incoming_state.count + 1;
            }
        } else if incoming_state.timestamp < inner.state.timestamp {
            // Our timestamp is ahead of the incoming timestamp, so it remains unchanged.
            // We only need to update the logical count.
            inner.state.count += 1;
        } else {
            // Timestamps are equal, so we need to use the maximum logical count for update.
            if incoming_state.count > inner.state.count {
                inner.state.count = incoming_state.count;
            }
            inner.state.count += 1;
        };

        Ok(inner.state.clone())
    }
}

fn current_timestamp() -> Option<i64> {
    // Get the current time in nanoseconds since the Unix epoch.
    Utc::now().timestamp_nanos_opt()
}
