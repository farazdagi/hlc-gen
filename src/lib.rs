#![doc = include_str!("../README.md")]

pub mod error;

use {
    crate::error::{HlcError, HlcResult},
    chrono::Utc,
    parking_lot::RwLock,
    std::sync::Arc,
};

/// Hybrid logical clock (HLC) timestamp.
#[derive(Hash, Clone, PartialEq, Eq, PartialOrd, Ord, Debug)]
pub struct HlcTimestamp {
    /// Wall-clock time.
    ///
    /// Timestamp in nanoseconds since the Unix epoch.
    pt: i64,

    /// The logical clock value.
    ///
    /// Captures causality for events that occur at the same wall-clock time.
    lc: u64,
}

impl HlcTimestamp {
    /// Creates a new HLC timestamp.
    pub fn new() -> Self {
        Self {
            pt: current_timestamp().unwrap_or(0),
            lc: 0,
        }
    }

    /// Creates a new timestamp with the specified physical time and logical
    /// clock count.
    pub fn from_parts(timestamp: i64, count: u64) -> Self {
        Self {
            pt: timestamp,
            lc: count,
        }
    }

    /// Returns the wall-clock time in nanoseconds since the Unix epoch.
    pub fn timestamp(&self) -> i64 {
        self.pt
    }

    /// Returns the logical clock value.
    pub fn count(&self) -> u64 {
        self.lc
    }
}

impl Default for HlcTimestamp {
    fn default() -> Self {
        Self::new()
    }
}

/// Hybrid Logical Clock (HLC) generator.
pub struct HlcGenerator {
    inner: Arc<RwLock<InnerHlcClock>>,
}

struct InnerHlcClock {
    /// The maximum drift (in nanoseconds) allowed between the physical clock
    /// and the wall-clock time.
    max_drift: usize,

    /// The last timestamp generated by the clock.
    state: HlcTimestamp,
}

impl Default for HlcGenerator {
    fn default() -> Self {
        Self::new()
    }
}

impl HlcGenerator {
    /// Creates a new HLC clock without any drift.
    ///
    /// Whenever the clock running on a single node is required, there is no
    /// need to worry about drift, as no adjustments are made to the clock,
    /// i.e. [`update()`](HlcGenerator::update) is never called.
    pub fn new() -> Self {
        Self::with_max_drift(0)
    }

    /// Creates a new HLC clock with the specified maximum drift.
    pub fn with_max_drift(max_drift: usize) -> Self {
        Self {
            inner: Arc::new(RwLock::new(InnerHlcClock {
                max_drift,
                state: HlcTimestamp {
                    pt: current_timestamp().unwrap_or(0),
                    lc: 0,
                },
            })),
        }
    }

    /// Current timestamp.
    ///
    /// Use [`next_timestamp()`](HlcGenerator::next_timestamp) to get the
    /// timestamp for local or send events.
    pub fn timestamp(&self) -> HlcTimestamp {
        let inner = self.inner.read();
        inner.state.clone()
    }

    /// Timestamp for the local or send event.
    pub fn next_timestamp(&self) -> Option<HlcTimestamp> {
        let mut inner = self.inner.write();

        let timestamp = current_timestamp()?;
        if inner.state.pt >= timestamp {
            // Known timestamp is not outdated, increment the logical count.
            inner.state.lc += 1;
        } else {
            // Known timestamp is outdated, update timestamp and reset the logical count.
            inner.state.lc = 0;
        }
        Some(inner.state.clone())
    }

    /// Adjust the clock based on incoming timestamp.
    ///
    /// Usually this happens when a timestamp is received from another node.
    /// An error may occur if drift is exceeded (if `max_drift` is set to 0,
    /// then such a check is ignored).
    ///
    /// Updated timestamp is returned.
    pub fn update(&self, incoming_id: HlcTimestamp) -> HlcResult<HlcTimestamp> {
        let mut inner = self.inner.write();

        let timestamp = current_timestamp().ok_or(HlcError::OutOfRangeTimestamp)?;

        // Physical clock is ahead of both the incoming timestamp and the current state.
        if timestamp > incoming_id.pt && timestamp > inner.state.pt {
            // Update the clock state.
            inner.state = HlcTimestamp {
                pt: timestamp,
                lc: 0,
            };
            return Ok(inner.state.clone());
        }

        if incoming_id.pt > inner.state.pt {
            // Check for drift.
            let drift = (incoming_id.pt - timestamp) as usize;
            if inner.max_drift > 0 && drift > inner.max_drift {
                return Err(HlcError::DriftTooLarge(drift, inner.max_drift));
            } else {
                // Remote timestamp is ahead of the current state. Update local state.
                inner.state.pt = incoming_id.pt;
                inner.state.lc = incoming_id.lc + 1;
            }
        } else if incoming_id.pt < inner.state.pt {
            // Our timestamp is ahead of the incoming timestamp, so it remains unchanged.
            // We only need to update the logical count.
            inner.state.lc += 1;
        } else {
            // Timestamps are equal, so we need to use the maximum logical count for update.
            if incoming_id.lc > inner.state.lc {
                inner.state.lc = incoming_id.lc;
            }
            inner.state.lc += 1;
        };

        Ok(inner.state.clone())
    }
}

fn current_timestamp() -> Option<i64> {
    // Get the current time in nanoseconds since the Unix epoch.
    Utc::now().timestamp_nanos_opt()
}
